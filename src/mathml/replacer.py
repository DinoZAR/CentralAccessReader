'''
Created on Feb 3, 2013

This file has classes and functions that work on the MathML pattern matching
and replacement to spoken text.

@author: Spencer Graffe
'''
import copy
import string

def run(mathMLDom, patternTree, stageSink=None):
    '''
    Runs the replacement algorithm on the MathML DOM given a set of patterns
    from a tree generated by the math database parser. After it has done that,
    it will then traverse the tree to piece together the spoken text. Returns
    a string representing the spoken text.
    '''
    
    # First, get a default ReplaceTree from the DOM
    myTree = _domToReplaceTree(mathMLDom, None)
    
    # Get list of patterns I must match
    patterns = patternTree.children
    
    if stageSink != None:
        newTree = copy.deepcopy(myTree)
        newTree.replaceVariable = 'START'
        stageSink.append(newTree)
    
    # For each pattern, perform search and replace on all instances
    for pattern in patterns:
        foundMatch = _searchAndReplace(myTree, pattern.getReplaceTree(), pattern.output.value)
        if (stageSink != None) and foundMatch:
            newTree = copy.deepcopy(myTree)
            newTree.replaceVariable = pattern.variable.value
            stageSink.append(newTree)
            
    
    return myTree


def _searchAndReplace(replaceTree, pattern, output):
    
    # First stage is finding and replacing all patterns found in the main tree
    import matcher
    
    foundMatches = matcher.matchAndPrepare(replaceTree, pattern, output)
    if foundMatches:
        _replaceAndRemove(replaceTree)
        
    # Next, search inside the expressions of all speech objects in the tree.
    # If my root is a MathML object, then I have to iterate through it to find
    # all of the speech objects and their expressions
    if replaceTree.type == ReplaceTree.MATHML:
        iterator = DepthFirstIterator(replaceTree)
        while iterator.hasNext():
            currNode = iterator.next()
            
            # Handle expressions in speech object, if found
            if currNode[0].type == ReplaceTree.SPEECH:
                foundInExpressions = _searchAndReplaceExpressions(currNode[0], pattern, output)
                foundMatches = foundMatches or foundInExpressions
                                    
    # Else, treat it like a speech object
    else:
        foundInExpressions = _searchAndReplaceExpressions(replaceTree, pattern, output)
        foundMatches = foundMatches or foundInExpressions
    
    return foundMatches


def _searchAndReplaceExpressions(speechObject, pattern, output):
    foundMatches = False
    if len(speechObject.expressions) > 0:
        for i in range(len(speechObject.expressions)):
            if isinstance(speechObject.expressions[i], ReplaceTree):
                if speechObject.expressions[i].type == ReplaceTree.MATHML:
                    foundMatches = _searchAndReplace(speechObject.expressions[i], pattern, output) or foundMatches
                else:
                    foundMatches = _searchAndReplaceExpressions(speechObject.expressions[i], pattern, output) or foundMatches
            else:
                for j in range(len(speechObject.expressions[i])):
                    if speechObject.expressions[i][j].type == ReplaceTree.MATHML:
                        foundMatches = _searchAndReplace(speechObject.expressions[i][j], pattern, output) or foundMatches
                    else:
                        foundMatches = _searchAndReplaceExpressions(speechObject.expressions[i][j], pattern, output) or foundMatches
                    
    return foundMatches


def _replaceAndRemove(replaceTreeRoot):
    '''
    Finds nodes that need to be replaced with SPEECH objects and deletes nodes
    that are marked for removal.
    '''
    
    iter = DepthFirstIterator(replaceTreeRoot)
    
    while iter.hasNext():
        data = iter.next()
        node = data[0]
        level = data[1]
        
        if node.mark == ReplaceTree.REPLACE:
            # Go to its parent, linearly search its children for node marked
            # "REPLACE", and then replace with SPEECH object
            
            # If node doesn't have parent, then it IS the root
            parent = node.parent
            if parent != None:
                for i in range(len(parent.children)):
                    if parent.children[i].mark == ReplaceTree.REPLACE:
                        newNode = ReplaceTree()
                        
                        newNode.type = ReplaceTree.SPEECH
                        newNode.parent = parent.children[i].parent
                        newNode.value = parent.children[i].replaceVariable
                        newNode.expressions = parent.children[i].expressions
                        
                        # Check if I have a numbered multiexpression.
                        # In that case, use a counter and append a number before
                        # each expression.
#                         if parent.children[i].isAnyNumber:
#                             count = 1
#                             newNode.expressions = []
#                             for ex in parent.children[i].expressions:
#                                 # Create numbered speech first
#                                 countNode = ReplaceTree()
#                                 countNode.type = ReplaceTree.SPEECH
#                                 countNode.value = 'countNumber'
#                                 countNode.speechReplace = 'countNumber'
#                                 countNode.output = str(count) + ','
#                                 newNode.expressions.append(countNode)
#                                 newNode.expressions.append(ex)
#                                 
#                         else:
                        
                        # Clear whatever mark is on those expressions
                        for j in range(len(newNode.expressions)):
                            if isinstance(newNode.expressions[j], ReplaceTree):
                                newNode.expressions[j].mark = ReplaceTree.NONE
                                newNode.expressions[j].parent = None
                                
                                # If the added expression is MathML, then clear REMOVE marks on all of its children
                                if newNode.expressions[j].type == ReplaceTree.MATHML:
                                    iterator = DepthFirstIterator(newNode.expressions[j])
                                    while iterator.hasNext():
                                        iterator.next()[0].mark = ReplaceTree.NONE
                            else:
                                # It's a list of nodes that we need to clear
                                for k in range(len(newNode.expressions[j])):
                                    newNode.expressions[j][k].mark = ReplaceTree.NONE
                                    newNode.expressions[j][k].parent = None
                                    
                                    # If the added expression is MathML, then clear REMOVE marks on all of its children
                                    if newNode.expressions[j][k].type == ReplaceTree.MATHML:
                                        iterator = DepthFirstIterator(newNode.expressions[j][k])
                                        while iterator.hasNext():
                                            iterator.next()[0].mark = ReplaceTree.NONE
                                                    
                        newNode.categories = parent.children[i].categories
                        
                        # Take out the single quotes in output
                        newNode.output = parent.children[i].output.replace('\'', '')
                        
                        parent.children[i] = newNode
                        break
                
                # Now start over, but now from the parent
                iter = DepthFirstIterator(parent, level=level - 1, rootResume=True)
                
            else:
                # Just mutate the root to my will
                replaceTreeRoot.type = ReplaceTree.SPEECH
                replaceTreeRoot.parent = None
                replaceTreeRoot.value = replaceTreeRoot.replaceVariable
                        
                # Take out the single quotes
                replaceTreeRoot.output = replaceTreeRoot.output.replace('\'', '')
                
            
        elif node.mark == ReplaceTree.REMOVE:
            # Go up to parent, find this child, and remove it
            parent = node.parent
            for i in range(len(parent.children)):
                if parent.children[i].mark == ReplaceTree.REMOVE:
                    parent.children.pop(i)
                    break
            
            # Start over from parent
            iter = DepthFirstIterator(parent, level=level - 1, rootResume=True)
        
                      
class DepthFirstIterator():
    '''
    Iterator used to iterate through a tree structure depth-first. The only
    requirements it needs is that the tree must have self.children that's type
    list and that the tree has .isCurrParent (for root resumes).
    '''
    
    def __init__(self, treeRoot, level=0, rootResume=False):
        self.fringe = []        # Stack that I'm using to add new elements into
        
        if rootResume:
            # Append the elements required from parent so that it appears that
            # we are "resuming" from where we started.
            
            # This means we have to only add children of the parents that have
            # not been visited yet. Practically, this means we need to add the
            # future siblings of self, its parent's future siblings, and so on.
            treeRoot.isCurrParent = True
            if treeRoot.parent != None:
                self.fringe.extend(self._reconstructAncestor(treeRoot.parent, level - 1))
                self.fringe.reverse()
        
        # Add the root to my fringe. Also keep track of depth of node
        self.fringe.append((treeRoot, level))
    
    def _reconstructAncestor(self, node, level):
        myList = []
        node.isCurrParent = True
        
        #print 'Parent:', node.value
        
        # Add children first (starting after node tagged with isCurrParent)
        appending = False
        for i in range(len(node.children)):
            #print 'Child:', node.children[i].value
            if node.children[i].isCurrParent:
                appending = True
                node.children[i].isCurrParent = False   # Clear after we don't need it
            else:
                if appending:
                    #print 'Appending!'
                    myList.append((node.children[i], level + 1))
                else:
                    pass
                    #print 'Ignoring...'
        
        if node.parent == None:
            pass
        else:
            myList.extend(self._reconstructAncestor(node.parent, level - 1))
        
        return myList
        
    def next(self):
        
        data = self.fringe.pop()
        myTree = data[0]
        level = data[1]
        
        # Add that tree's children to the fringe, reverse order
        if len(myTree.children) > 0:
            for i in range(len(myTree.children)):
                index = len(myTree.children) - 1 - i
                self.fringe.append((myTree.children[index], level + 1))
                
        return data
                
    def hasNext(self):
        return len(self.fringe) > 0

class ReplaceTree():
    '''
    Tree structure used to replace MathML elements with corresponding spoken
    text or variables
    '''
    # Type Constants
    NOTHING = 0
    MATHML = 1
    TEXT = 2
    SPEECH = 3
    ANY = 4
    ANY_PLUS = 5
    ANY_NUMBER_PLUS = 6
    CATEGORY = 7
    
    # Marker Constants
    REMOVE = 4
    REPLACE = 5
    NONE = 6
    
    def __init__(self):
        self.type = ReplaceTree.NOTHING
        self.value = ''
        self.parent = None
        self.children = []
        self.mark = ReplaceTree.NONE      # Marker used during replacement process
        self.expressions = []             # Expressions given in search replacement
        self.replaceVariable = ''         # Variable that is used to create SPEECH object
        self.output = ''                  # Also used in creating SPEECH object
        self.categories = []              # Categories assigned to it in creating SPEECH object
        self.isAnyNumber = False          # Says if this tree is inside a ANY_NUMBER_PLUS tree
        
        # DepthFirstSearch variables
        self.isCurrParent = False            
        
    def dump(self, indent=0):
        myString = self._createIndent(indent) + unicode(self.value) + ' Type: ' + self._getTypeString()
        myString += ' Mark: ' + self._getMarkString()
        
        if self.parent != None:
            myString += ' (Parent: ' + self.parent.value + ' Type: ' + self.parent._getTypeString() + ')'
        
        if len(self.categories) > 0:
            myString += ' ['
            for c in self.categories:
                myString += c + ','
            myString += ']'
        
        if len(self.children) > 0:
            myString += ' {\n'
            for i in range(len(self.children)):
                myString += self.children[i].dump(indent + 1) + '\n'
            myString += self._createIndent(indent) + '}'
        
        return myString
    
    def isMatch(self, patternNode):
        '''
        Returns whether this node matches the pattern node in the argument.
        '''
        
        if patternNode.type == ReplaceTree.ANY:
            return True
        elif patternNode.type == ReplaceTree.ANY_PLUS:
            return True
        elif patternNode.type == ReplaceTree.ANY_NUMBER_PLUS:
            return True
        elif patternNode.type == ReplaceTree.CATEGORY:
            # In this case, I have to search through the categories and see if
            # any of them match one of the categories of the variable
            if self.type == ReplaceTree.SPEECH:
                for c1 in patternNode.value:
                    if len(self.categories) > 0:
                        for c2 in self.categories:
                            if c1 == c2:
                                return True
                # If we haven't found anything now, return false
                return False
            else:
                return False
        elif patternNode.type == self.type:
            return patternNode.value.strip() == self.value.strip()
        else:
            return False
    
    def __str__(self):
        return self.dump()
    
    def __repr__(self):
        return self.dump()
    
    def _createIndent(self, numIndents):
        myString = ''
        for i in range(numIndents):
            myString += '    '
        return myString
    
    def _getTypeString(self):
        if self.type == ReplaceTree.NOTHING:
            return 'Nothing'
        elif self.type == ReplaceTree.MATHML:
            return 'MathML'
        elif self.type == ReplaceTree.TEXT:
            return 'Text'
        elif self.type == ReplaceTree.SPEECH:
            return 'Speech Output'
        elif self.type == ReplaceTree.ANY:
            return 'Any'
        elif self.type == ReplaceTree.ANY_PLUS:
            return 'Any or Multiple'
        elif self.type == ReplaceTree.ANY_NUMBER_PLUS:
            return 'Any Numbered or Multiple Numbered'
        elif self.type == ReplaceTree.CATEGORY:
            return 'Category'
        else:
            return 'Unknown'
        
    def _getMarkString(self):
        if self.mark == ReplaceTree.REMOVE:
            return 'Remove'
        elif self.mark == ReplaceTree.REPLACE:
            return 'Replace'
        elif self.mark == ReplaceTree.NONE:
            return 'None'
        else:
            return 'Unknown'

def _domToReplaceTree(root, parent):
    '''
    Returns a replacement tree used for pattern matching and collapsing MathML
    elements and variables into spoken text.
    '''
    myTree = ReplaceTree()
    myTree.type = ReplaceTree.MATHML
    myTree.parent = parent
    
    # Remove namespace portion
    myTree.value = root.tag.split("}")[1]
    
    for child in root:
        
        newChild = ReplaceTree()
        newChild.value = child.tag.split("}")[1] # Remove namespace portion
        newChild.type = ReplaceTree.MATHML
        newChild.parent = myTree
        
        # If it has actual text in it, add that as its first child
        if child.text != None:
            if len(child.text.strip()) > 0:
                textNode = ReplaceTree()
                textNode.type = ReplaceTree.TEXT
                textNode.value = child.text.strip()
                textNode.parent = newChild
                newChild.children.append(textNode)
        
        if len(child) > 0:
            newChild =_domToReplaceTree(child, myTree)
            myTree.children.append(newChild)
        else:
            myTree.children.append(newChild)
        
    return myTree