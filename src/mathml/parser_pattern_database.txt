// --------------
// Order Matters!
// --------------
//
// The MathML parser is entirely sequential. Once it finds all cases of the
// current pattern and combines the different pattern's elements into singular
// entities, the pattern is no longer used in later matching. This means you
// must order patterns correctly to produce results you expect.
//
// -----------------
// Expected Ordering
// -----------------
//
// In order for patterns to match correctly, you should have patterns grouped
// and have those groups ordered in the following way: 
//
// 1. Symbol Code (like variables and Unicode)
// 2. Fraction-Based (like derivatives)
// 3. Over-Under (like sums and integrals)
// 4. Parenthetical Expressions (like square roots or things in parenthesis)
// 5. Generic Fallbacks (like fractions, superscripting, and subscripting)

// ------------------------------------------------------------------------------
// Symbol Code
// ------------------------------------------------------------------------------

// Unicodes and MathML codes for operators

plus = mo("+") -> 'plus'
plusMinus = mo("&#xB1;") -> 'plus minus'
minus = mo("-") -> 'minus'
minus = mo("&#x2212;") -> 'minus'
equals = mo("=") -> 'equals'
closedIntegral [integral] = mo("&#x222E;") -> 'closed integral'

// Arrows
rightarrow = mo("&#8594;") -> 'right arrow'

openParen = mo("(") -> 'open,'
closeParen = mo(")") -> ', closed, '

// Logic
lessThan = mo("&lt;") -> 'is less than'
greaterThan = mo("&gt;") -> 'is greater than'
therefore = mo("&#8756;") -> 'therefore,'
because = mo("&#8757;") -> 'because,'
suchThat = mo("&#8717;") -> 'such that,'

factorial = mo("!") -> 'factorial'

endPeriod = mo(".") -> ''
comma = mo(",") -> ','

// Letters
a [variable] = mi("a") -> '"a"'
b [variable] = mi("b") -> '"b"'
c [variable] = mi("c") -> '"c"'
d [variable] = mi("d") -> '"d"'
e [variable] = mi("e") -> '"e"'
f [variable] = mi("f") -> '"f"'
g [variable] = mi("g") -> '"g"'
h [variable] = mi("h") -> '"h"'
i [variable] = mi("i") -> '"i"'
j [variable] = mi("j") -> '"j"'
k [variable] = mi("k") -> '"k"'
l [variable] = mi("l") -> '"l"'
m [variable] = mi("m") -> '"m"'
n [variable] = mi("n") -> '"n"'
o [variable] = mi("o") -> '"o"'
p [variable] = mi("p") -> '"p"'
q [variable] = mi("q") -> '"q"'
r [variable] = mi("r") -> '"r"'
s [variable] = mi("s") -> '"s"'
t [variable] = mi("t") -> '"t"'
u [variable] = mi("u") -> '"u"'
v [variable] = mi("v") -> '"v"'
w [variable] = mi("w") -> '"w"'
x [variable] = mi("x") -> '"x"'
y [variable] = mi("y") -> '"y"'
z [variable] = mi("z") -> '"z"'

A [variable] = mi("A") -> '"A"'
B [variable] = mi("B") -> '"B"'
C [variable] = mi("C") -> '"C"'
D [variable] = mi("D") -> '"D"'
E [variable] = mi("E") -> '"E"'
F [variable] = mi("F") -> '"F"'
G [variable] = mi("G") -> '"G"'
H [variable] = mi("H") -> '"H"'
I [variable] = mi("I") -> '"I"'
J [variable] = mi("J") -> '"J"'
K [variable] = mi("K") -> '"K"'
L [variable] = mi("L") -> '"L"'
M [variable] = mi("M") -> '"M"'
N [variable] = mi("N") -> '"N"'
O [variable] = mi("O") -> '"O"'
P [variable] = mi("P") -> '"P"'
Q [variable] = mi("Q") -> '"Q"'
R [variable] = mi("R") -> '"R"'
S [variable] = mi("S") -> '"S"'
T [variable] = mi("T") -> '"T"'
U [variable] = mi("U") -> '"U"'
V [variable] = mi("V") -> '"V"'
W [variable] = mi("W") -> '"W"'
X [variable] = mi("X") -> '"X"'
Y [variable] = mi("Y") -> '"Y"'
Z [variable] = mi("Z") -> '"Z"'

// Greek letters
alpha [variable] = mi("&#945;") -> 'alpha'
beta [variable] = mi("&#946;") -> 'beta'
gamma [variable] = mi("&#947;") -> 'gamma'
delta [variable] = mi("&#948;") -> 'delta'
delta [variable] = mi("&#8706;") -> 'delta'
epsilon [variable] = mi("&#949;") -> 'epsilon'
zeta [variable] = mi("&#950;") -> 'zeta'
eta [variable] = mi("&#951;") -> 'eta'
theta [variable] = mi("&#952;") -> 'theta'
iota [variable] = mi("&#953;") -> 'iota'
kappa [variable] = mi("&#954;") -> 'kappa'
lambda [variable] = mi("&#955;") -> 'lambda'
mu [variable] = mi("&#956;") -> 'mu'
nu [variable] = mi("&#957;") -> 'nu'
xi [variable] = mi("&#958;") -> 'xi'
omicron [variable] = mi("&#959;") -> 'omicron'
pi [variable] = mi("&#960;") -> 'pi'
rho [variable] = mi("&#961;") -> 'rho'
sigma [variable] = mi("&#962;") -> 'sigma'
sigma [variable] = mi("&#963;") -> 'sigma'
tau [variable] = mi("&#964;") -> 'tau'
upsilon [variable] = mi("&#965;") -> 'upsilon'
phi [variable] = mi("&#966;") -> 'phi'
chi [variable] = mi("&#967;") -> 'chi'
psi [variable] = mi("&#968;") -> 'psi'
omega [variable] = mi("&#969;") -> 'omega'

Alpha [variable] = mi("&#913;") -> 'alpha'
Beta [variable] = mi("&#914;") -> 'beta'
Gamma [variable] = mi("&#915;") -> 'gamma'
Delta [variable] = mi("&#916;") -> 'delta'
Epsilon [variable] = mi("&#917;") -> 'epsilon'
Zeta [variable] = mi("&#918;") -> 'zeta'
Eta [variable] = mi("&#919;") -> 'eta'
Theta [variable] = mi("&#920;") -> 'theta'
Iota [variable] = mi("&#921;") -> 'iota'
Kappa [variable] = mi("&#922;") -> 'kappa'
Lambda [variable] = mi("&#923;") -> 'lambda'
Mu [variable] = mi("&#924;") -> 'mu'
Nu [variable] = mi("&#925;") -> 'nu'
Xi [variable] = mi("&#926;") -> 'xi'
Omicron [variable] = mi("&#927;") -> 'omicron'
Pi [variable] = mi("&#928;") -> 'pi'
BigPi = mo("&#8719;") -> 'big pi'
Rho [variable] = mi("&#929;") -> 'rho'
Sigma [variable] = mi("&#931;") -> 'sigma'
BigSigma = mo("&#8721;") -> 'sigma'
Tau [variable] = mi("&#932;") -> 'tau'
Upsilon [variable] = mi("&#933;") -> 'upsilon'
Phi [variable] = mi("&#934;") -> 'phi'
Chi [variable] = mi("&#935;") -> 'chi'
Psi [variable] = mi("&#936;") -> 'psi'
Omega [variable] = mi("&#937;") -> 'omega'

// Other symbols
infinity = mi("&#8734;") -> 'infinity'
infinity = mn("&#8734;") -> 'infinity'

// Trigonometry
sine = s i n -> 'sine'
cosine = c o s -> 'cosine'
arcsine = a r c s i n -> 'arc sine'

// Numbers
zero = mn("0") -> 'zero'
one = mn("1") -> 'one'
two = mn("2") -> 'two'
three = mn("3") -> 'three'
four = mn("4") -> 'four'
five = mn("5") -> 'five'
six = mn("6") -> 'six'
seven = mn("7") -> 'seven'
eight = mn("8") -> 'eight'
nine = mn("9") -> 'nine'
ten = mn("10") -> 'ten'

// Powers
squared = msup(? mrow(two)) -> '{1} squared'
squared = msup(? two) -> '{1} squared'
cubed = msup(? mrow(three)) -> '{1} cubed'
cubed = msup(? three) -> '{1} cubed'

function = [variable] mrow(openParen [variable] closeParen) -> 'function {1} of {3}'
function = [variable] openParen [variable] closeParen -> 'function {1} of {3}'
function = [variable] mfenced(+) -> 'function {1} of {2}'

functionPrime = [variable] mi("'") mfenced(+) -> 'function {1} prime of {2}'

// ------------------------------------------------------------------------------
// Fraction-based
// ------------------------------------------------------------------------------
integral = msub([integral] ?) -> '{1} sub {2} of'

// ------------------------------------------------------------------------------
// Under-Over
// ------------------------------------------------------------------------------
sum = munderover(BigSigma ? ?) -> 'the sum starting from {2} to {3},'
product = munderover(BigPi mrow() mrow()) -> 'the product of,'
product = munderover(BigPi ? ?) -> 'the product starting from {2} to {3},'
limit = munderover(mrow(l i m) mrow(? ? ?) ?) -> 'the limit as {4} approaches {6} of'

underover = munderover(? ? ?) -> 'the {1} starting from, {2}, to {3}, of'

// ------------------------------------------------------------------------------
// Parenthetical Expressions
// ------------------------------------------------------------------------------
squareRoot = msqrt(+) -> 'the square root of {1}'

// ------------------------------------------------------------------------------
// Matrices
// ------------------------------------------------------------------------------
tableColumn = mtd(+) -> '{1},'
tableRow = mtr(#) -> 'row {1}'
matrix = mfenced(mrow(mtable(+))) -> 'matrix {1}'


// ------------------------------------------------------------------------------
// Generic Fallbacks, Final Collectors
// ------------------------------------------------------------------------------
fenced = mfenced(+) -> 'open, {1}, closed,'

subscript = msub(? ?) -> '{1} sub {2}'
superscript = msup(? ?) -> '{1} to the {2} power'
subsuperscript = msubsup(? ? ?) -> '{1} sub {2} to the {3} power'
fraction = mfrac(? ?) -> '{1} over {2}'

style = mstyle(+) -> '{1}'
row = mrow(+) -> '{1}'
row = mrow() -> ''

// This is the final collapsing pattern
final = math(+) -> '{1}'