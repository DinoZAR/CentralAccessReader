# Author: Spencer Graffe
#
# This is what the MathML parser uses to recognize patterns and convert them to
# naturally read text. This will describe how one enters symbols that the MathML
# parser should recognize and convert to text.
#
# --------------------------
# Pattern Language Primer
# --------------------------
#
# First and foremost, '#' are used to make comments. Anything beyond the '#' 
# symbol is ignored by the parser till the end of the line.
#
# To create a pattern, you write it in the following format (replacing the
# parts with the <> with your own words):
#
# <variable> [<categories>] = <pattern> -> '<output>'
#
# The variable is the single speech object that the parser collapses the
# pattern into. The variable can also be used later in future patterns
# that require it.
#
# Categories are, well, categories that the variable falls under. It's
# treated as if the variable has been added to that category. Later on in
# future patterns, you could use [<category>] to refer to all variables that
# are defined in that category. Finally, a variable can be under multiple
# categories by using comma separation, i.e., [<category>, <anothercategory>...]
#
# For MathML in a pattern, you represent it as <tag>(). Whatever is inside the
# parenthesis is what's inside of that MathML element.
#
# '?' are used to match one thing that could be anything.
#
# '+' are used to match EVERYTHING in that level.
#
# Using "" around text refers to the text inside of an XML tag. For now, the
# text must match exactly character-per-character for the match to be
# successful.
#
# Finally, the output portion is always surrounded by single quotes. To use
# the text generated by the variables and those accumulated by the '?' and
# '+', you use {<numOfVariable>}, the number determined by the order of
# appearance of the variable in the pattern.

# --------------
# Order Matters!
# --------------
#
# The MathML parser is entirely sequential. Once it finds all cases of the
# current pattern and combines the different pattern's elements into singular
# entities, the pattern is no longer used in later matching. This means you
# must order patterns correctly to produce results you expect.
#
# -----------------
# Expected Ordering
# -----------------
#
# In order for patterns to match correctly, you should have patterns grouped
# and have those groups ordered in the following way: 
#
# 1. Symbol Code (like variables and Unicode)
# 2. Fraction-Based (like derivatives)
# 3. Over-Under (like sums and integrals)
# 4. Parenthetical Expressions (like square roots or things in parenthesis)
# 5. Generic Fallbacks (like fractions, superscripting, and subscripting)


# ------------------------------------------------------------------------------
# Symbol Code
# ------------------------------------------------------------------------------

# Unicodes and MathML codes for operators

plus = mo("+") -> 'plus'
plusMinus = mo("&#xB1;") -> 'plus minus'
minus = mo("-") -> 'minus'
minus = mo("&#x2212;") -> 'minus'
equals = mo("=") -> 'equals'
closedIntegral [integral] = mo("&#x222E;") -> 'closed integral'
sum = mo("&#x2211;") -> 'sum'

rightarrow = mo("&#8594;") -> 'right arrow'

openParen = mo("(") -> 'open,'
closeParen = mo(")") -> ', closed, '

lessThan = mo("&lt;") -> 'is less than'
greaterThan = mo("&gt;") -> 'is greater than'

factorial = mo("!") -> 'factorial'

endPeriod = mo(".") -> ''
comma = mo(",") -> ','

# Letters
a [variable] = mi("a") -> '"a"'
b [variable] = mi("b") -> '"b"'
c [variable] = mi("c") -> '"c"'
d [variable] = mi("d") -> '"d"'
e [variable] = mi("e") -> '"e"'
f [variable] = mi("f") -> '"f"'
g [variable] = mi("g") -> '"g"'
h [variable] = mi("h") -> '"h"'
i [variable] = mi("i") -> '"i"'
j [variable] = mi("j") -> '"j"'
k [variable] = mi("k") -> '"k"'
l [variable] = mi("l") -> '"l"'
m [variable] = mi("m") -> '"m"'
n [variable] = mi("n") -> '"n"'
o [variable] = mi("o") -> '"o"'
p [variable] = mi("p") -> '"p"'
q [variable] = mi("q") -> '"q"'
r [variable] = mi("r") -> '"r"'
s [variable] = mi("s") -> '"s"'
t [variable] = mi("t") -> '"t"'
u [variable] = mi("u") -> '"u"'
v [variable] = mi("v") -> '"v"'
w [variable] = mi("w") -> '"w"'
x [variable] = mi("x") -> '"x"'
y [variable] = mi("y") -> '"y"'
z [variable] = mi("z") -> '"z"'

A [variable] = mi("A") -> '"A"'
B [variable] = mi("B") -> '"B"'
C [variable] = mi("C") -> '"C"'
D [variable] = mi("D") -> '"D"'
E [variable] = mi("E") -> '"E"'
F [variable] = mi("F") -> '"F"'
G [variable] = mi("G") -> '"G"'
H [variable] = mi("H") -> '"H"'
I [variable] = mi("I") -> '"I"'
J [variable] = mi("J") -> '"J"'
K [variable] = mi("K") -> '"K"'
L [variable] = mi("L") -> '"L"'
M [variable] = mi("M") -> '"M"'
N [variable] = mi("N") -> '"N"'
O [variable] = mi("O") -> '"O"'
P [variable] = mi("P") -> '"P"'
Q [variable] = mi("Q") -> '"Q"'
R [variable] = mi("R") -> '"R"'
S [variable] = mi("S") -> '"S"'
T [variable] = mi("T") -> '"T"'
U [variable] = mi("U") -> '"U"'
V [variable] = mi("V") -> '"V"'
W [variable] = mi("W") -> '"W"'
X [variable] = mi("X") -> '"X"'
Y [variable] = mi("Y") -> '"Y"'
Z [variable] = mi("Z") -> '"Z"'

# Greek letters
gamma [variable] = mi("&#x3B3;") -> 'gamma'
pi [variable] = mi("&#x3C0;") -> 'pi'
sigma [variable] = mi("&#x3C3;") -> 'sigma'
mu [variable] = mi("&#x3BC;") -> 'mu'

# Other symbols
infinity = mi("&#8734;") -> 'infinity'
infinity = mn("&#8734;") -> 'infinity'

# Trigonometry
arcsine = a r c s i n -> 'arc sine'

# Numbers
zero = mn("0") -> 'zero'
one = mn("1") -> 'one'
two = mn("2") -> 'two'
three = mn("3") -> 'three'
four = mn("4") -> 'four'
five = mn("5") -> 'five'
six = mn("6") -> 'six'
seven = mn("7") -> 'seven'
eight = mn("8") -> 'eight'
nine = mn("9") -> 'nine'
ten = mn("10") -> 'ten'

# Powers
squared = msup(? mrow(two)) -> '{1} squared'
squared = msup(? two) -> '{1} squared'
cubed = msup(? mrow(three)) -> '{1} cubed'
cubed = msup(? three) -> '{1} cubed'

function = [variable] mrow(openParen [variable] closeParen) -> 'function {1} of {3}'
function = [variable] openParen [variable] closeParen -> 'function {1} of {3}'
function = [variable] mfenced(+) -> 'function {1} of {2}'

functionPrime = [variable] mi("'") mfenced(+) -> 'function {1} prime of {2}'

# ------------------------------------------------------------------------------
# Fraction-based
# ------------------------------------------------------------------------------
integral = msub([integral] ?) -> '{1} sub {2} of'

# ------------------------------------------------------------------------------
# Under-Over
# ------------------------------------------------------------------------------
underover = munderover(? ? ?) -> 'the {1} starting from, {2}, to {3}, of'

# ------------------------------------------------------------------------------
# Parenthetical Expressions
# ------------------------------------------------------------------------------
squareRoot = msqrt(+) -> 'the square root of {1}'


# ------------------------------------------------------------------------------
# Generic Fallbacks, Final Collectors
# ------------------------------------------------------------------------------
fenced = mfenced(+) -> 'open, {1}, closed,'

subscript = msub(? ?) -> '{1} sub {2}'
superscript = msup(? ?) -> '{1} to the {2} power'
subsuperscript = msubsup(? ? ?) -> '{1} sub {2} to the {3} power'
fraction = mfrac(? ?) -> '{1} over {2}'

style = mstyle(+) -> '{1}'
row = mrow(+) -> '{1}'

# This is the final collapsing pattern
final = math(+) -> '{1}'