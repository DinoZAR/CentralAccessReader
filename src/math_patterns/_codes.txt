// ------------
// Common Signs
// ------------
//
// --------------
// Order Matters!
// --------------
//
// The MathML parser is entirely sequential. Once it finds all cases of the
// current pattern and combines the different pattern's elements into singular
// entities, the pattern is no longer used in later matching. This means you
// must order patterns correctly to produce results you expect.
//
// -----------------
// Expected Ordering
// -----------------
//
// In order for patterns to match correctly, you should have patterns grouped
// and have those groups ordered in the following way: 
//
// 1. Symbol Code (like variables and Unicode)
// 2. Fraction-Based (like derivatives)
// 3. Over-Under (like sums and integrals)
// 4. Parenthetical Expressions (like square roots or things in parenthesis)
// 5. Generic Fallbacks (like fractions, superscripting, and subscripting)

//
// ------------------------------------------------------------------------------
// Symbol Code
// ------------------------------------------------------------------------------

// Unicodes and MathML codes for operators



ampersand = mi("&amp;") -> 'ampersand,'
approxEqual = mi("&#8771;") -> 'is approximately equal to,'

approxEqualTilde = mi("&#8773;") -> 'is approximately equal to,'
apostrophe = mi("'") -> 'apostrophe'

approxEqual = mi("&#8776;") -> 'is approximately equal to,'

at = mi("@") -> 'at'

caret = mo("&#710;") -> 'caret,'

caret = mo("^") -> 'caret,'

circleCross = mi("&#8855;") -> 'circled cross,'

circleDot = mi("&#8857;") -> 'circled dot,'

circlePlus = mi("&#8853;") -> 'circled plus,'

colon = mi(":") -> 'colon'

comma = mi(",") -> ','

coproduct [integral] = mi("&#8720;") -> 'coproduct,'

coproduct [integral] = mo("&#8720;") -> 'coproduct,'

composition = mi("&#8728;") -> 'composition of,'

dagger = mi("&#8224;") -> 'dagger,'

divideBack = mo("&#247;") -> 'divided by,'

divideBack = mi("\") -> 'divided by,'

divide = mo("/") -> 'divided by,'

dollarSign = mi("$") -> 'dollar sign,'

equals = mo("=") -> 'equals'

equivalent = mi("&#8764;") -> 'is equivalent to,'

greaterThanOrEqual = mi("&#8805;") -> 'is greater than or equal to,'

lessThanOrEqual = mi("&#8804;") -> ' is less than or equal to,'

minus = mo("-") -> 'minus,'

minus = mo("&#x2212;") -> 'minus,'

minusPlus = mi("&#8723;") -> 'minus or plus,'

muchLessThan = mi("&#8810;") -> 'is much less than,'

muchGreaterThan = mi("&#8811;") -> 'is much greater than,'

minus = mo("&#8722;") -> 'minus,'

notEqual = mi("&#8800;") -> 'is not equal to,'

percent = mi("%") -> 'percent,'
plusMinus = mo("&#xB1;") -> 'plus or minus,'
product [integral] = mi("&#8719;") -> 'product,'

product [integral] = mo("&#8719;") -> 'product,'
times = mo("*") -> 'times,'

timesCross = mo("&#215;") -> 'times,'

times = mi("&#8727;") -> 'times,'



//Integrals
areaIntegral [integral] = mo("&#60946;") -> 'area integral'
areaIntegral [integral] = mo("&#8751;") -> 'area integral of'
closedIntegral [integral] = mo("&#x222E;") -> 'closed integral'
integral [integral] = mi("&#8747;") -> 'integral of'
integral [integral] = mo("&#8747;") -> 'integral of'
integralCCW [integral] = mo("&#8755;") -> 'integral with a counter-clockwise circle of'
integralCon [integral] = mo("&#60945;") -> 'contour integral'
integralCon [integral] = mo("&#8750;") -> 'contour integral'
integralCW [integral] = mo("&#8754;") -> 'integral with a clockwise circle of'
volumeIntegral [integral] = mo("&#8752;") -> 'volume integral of'
volumeIntegral [integral] = mo("&#60947;") -> 'volume integral of'

// Arrows
bothArrow [arrow] = mo("&#8596;") -> 'arrow pointing both left and right'
bothArrow [arrow] = mo("&#10231;") -> 'arrow pointing both left and right'
diagBothArrowLR [arrow] = mi("&#60165;") -> 'diagonal arrow pointing both bottom left and top right'
diagBothArrowRL [arrow] = mi("&#60166;") -> 'diagonal arrow pointing both top left and bottom right'
diagBotLeftArrow [arrow] = mi("&#8601;") -> 'diagonal arrow pointing from top right to bottom left'
diagBotRightArrow [arrow] = mi("&#8600;") -> 'diagonal arrow pointing from top left to bottom right'
diagTopRightArrow [arrow] = mi("&#8599;") -> 'diagonal arrow pointing from bottom left to top right'
diagTopLeftArrow [arrow] = mi("&#8598;") -> 'diagonal arrow pointing from bottom right to top left'
doubleDownArrow [arrow] = mi("&#8659;") -> 'double-arrow pointing down'
doubleLeftRightArrow [arrow] = mi("&#8660;") -> 'double-arrow pointing both left and right'
doubleLeftArrow [arrow] = mi("&#8656;") -> 'double-arrow pointing left'
doubleRightArrow [arrow] = mi("&#8658;") -> 'double-arrow pointing right'
doubleUpArrow [arrow] = mi("&#8657;") -> 'double-arrow pointing up'
doubleUpDownArrow [arrow] = mi("&#8661;") -> 'double-arrow pointing both up and down'
downArrow [arrow] = mi("&#8595;") -> 'arrow pointing down'
downLeftArrow [arrow] = mi("&#8629;") -> 'arrow pointing down then left'
dualArrows [arrow] = mi("&#8644;") -> 'right-pointing arrow atop a left-pointing arrow'
dualArrows [arrow] = mo("&#8644;") -> 'right-pointing arrow atop a left-pointing arrow'
dualArrowsBigTop [arrow] = mi("&#60161;") -> 'right-pointing arrow atop a small left-pointing arrow'
dualArrowsSmallTop [arrow] = mi("&#60162;") -> 'small right-pointing arrow atop a left-pointing arrow'
dualHarpoons [arrow] = mi("&#8652;") -> 'right-pointing harpoon above a left-pointing harpoon'
dualHarpoonsBigTop [arrow] = mi("&#60163;") -> 'right-pointing harpoon above a small left-pointing harpoon'
dualHarpoonsSmallTop [arrow] = mi("&#60164;") -> 'small right-pointing harpoon above a left-pointing harpoon'
leftArrow [arrow] = mo("&#8592;") -> 'left-pointing arrow'
leftHarpoon [arrow] = mo("&#8636;") -> 'left-pointing harpoon'
leftHarpoon [arrow] = mo("&#8637;") -> 'left-pointing harpoon'
rightArrow [arrow] = mo("&#8594;") -> 'right-pointing arrow'
rightArrowBar [arrow] = mi("&#8614;") -> 'right-pointing arrow originating from a vertical bar'
rightHarpoon [arrow] = mo("&#8640;") -> 'right-pointing harpoon'
rightHarpoon [arrow] = mo("&#8641;") -> 'right-pointing harpoon'
upArrow [arrow] = mi("&#8593;") -> 'arrow pointing up'
upDownArrow [arrow] = mi("&#8597;") -> 'arrow point both up and down'

doubleVerticalBars = mo("&#8214;") -> 'double vertical bars,'
horizontalBraceDown = mo("&#65079;") -> 'horizontal brace opening downward,'

horizontalBraceUp = mo("&#65080;") -> 'horizontal brace opening upward,'

horizontalBracketDown = mo("&#9140;") -> 'horizontal bracket opening downward,'

horizontalBracketUp = mo("&#9141;") -> 'horizontal bracket opening upward,'

leftSquareBracket = mi("&#12314;") -> 'left square bracket,'

leftSquareBracket = mo("&#12314;") -> 'left square bracket,'

openParen = mo("(") -> 'open parentheses,'

rightSquareBracket = mi("&#12315;") -> 'right square bracket,'

rightSquareBracket = mo("&#12315;") -> 'right square bracket,'

verticalBar = mi("|") -> 'vertical bar,'

verticalBar = mo("|") -> 'vertical bar,'



// Primes and Dots

backPrime = mo("&#8245;") -> 'back prime,'

doubleDot = mo("&#776;") -> 'double dot,'

doublePrime = mo("&#8243;") -> 'double prime,'

prime = mo("&#8242;") -> 'prime,'

quadDot = mo("&#8412;") -> 'quad dot,'

tripleDot = mo("&#8411;") -> 'triple dot,'

triplePrime = mo("&#8244;") -> 'triple prime,'



// Geometric Symbols

angle = mi("&#8736;") -> 'angle,'

angle = mi("&#8737;") -> 'measured angle,'

angle = mi("&#8738;") -> 'spherical angle,'

arc = mo("&#8994;") -> 'arc,'

arc = mo("&#8995;") -> 'arc,'

bar = mo("&#175;") -> 'bar,'

circle = mi("&#9675;") -> 'circle,'

degree = mi("&#176;") -> 'degrees,'

filledTriangle = mi("&#9650;") -> 'filled triangle,'

joint = mi("&#65081;") -> 'joint,'

multimap = mi("&#8888;") -> 'multimap,'

parallel = mi("&#8741;") -> 'parallel to,'

parallelogram = mi("&#9649;") -> 'parallelogram,'

parallelogram = mi("&#9645;") -> 'parallelogram,'

tortoiseShellBracket = mo("&#65081;") -> 'horizontal tortoise shell bracket opening downward,'

triangle = mi("&#9651;") -> 'triangle,'


// Logic
approachesLimit = mi("&#8784;") -> 'approaches the limit of,'

deltaEqual = mi("&#8796;") -> 'delta equal to,'

doubleSubSet = mi("&#8912;") -> 'is a double subset of,'

doubleSuperSet = mi("&#8913;") -> 'is a double superset of,'

emptySet = mi("&#8709;") -> 'the empty set,'

estimates = mi("&#8793;") -> 'estimates,'

intersection [integral] = mo("&#8745;") -> 'intersection,'

multimapRight = mi("&#168;") -> 'right multimap,'

multisetUnion = mi("&#8846;") -> 'is a multiset union of,'
normalSubgroup = mi("&#8882;") -> 'is normal subgroup of,'

notSubset = mo("&#8836;") -> 'is not a subset of,'

notSubNorEq = mi("&#59970;") -> 'not a subset of nor equal to,'

notSupNorEq = mi("&#59971;") -> 'not a superset of nor equal to,'

precedes = mi("&#8826;") -> 'precedes,'

proportional = mi("&#8733;") -> 'proportional to,'

squareImage = mi("&#8849;") -> 'is a square image of or equal to,'

squareOriginal = mi("&#8850;") -> 'is a square original of or equal to,'

subsetRight = mo("&#8838;") -> 'is a subset of,'

subsetLeft = mo("&#8839;") -> 'is a subset of,'

succeeds = mi("&#8827;") -> 'succeeds,'

suchThat = mo("&#8717;") -> 'such that,'

union [integral] = mo("&#8746;") -> 'union,'



// Periods And Spaces
comma = mo(",") -> ','

comma = mi(",") -> ','

endPeriod = mo(".") -> ''

point = mi(".") -> 'point,'
//space = mi("&#61185;") -> ' '
//space = mi("&#61186;") -> ' '
//space = mi("&#61188;") -> ' '
//space = mi("&#61189;") -> ' '
//space = mi("&#61192;") -> ' '
spaceXL = mi("&#8195;") -> ' '
spaceL = mi("&#8201;") -> ' '
spaceM = mi("&#8202;") -> ' '
spaceS = mi("&#8203;") -> ' '


// Letters
a [variable] = mi("a") -> '"a"'
b [variable] = mi("b") -> '"b"'
c [variable] = mi("c") -> '"c"'
d [variable] = mi("d") -> '"d"'

f [variable] = mi("f") -> '"f"'
g [variable] = mi("g") -> '"g"'
h [variable] = mi("h") -> '"h"'

j [variable] = mi("j") -> '"j"'
k [variable] = mi("k") -> '"k"'
l [variable] = mi("l") -> '"l"'
m [variable] = mi("m") -> '"m"'
n [variable] = mi("n") -> '"n"'
o [variable] = mi("o") -> '"o"'
p [variable] = mi("p") -> '"p"'
q [variable] = mi("q") -> '"q"'
r [variable] = mi("r") -> '"r"'
s [variable] = mi("s") -> '"s"'
t [variable] = mi("t") -> '"t"'
u [variable] = mi("u") -> '"u"'
v [variable] = mi("v") -> '"v"'
w [variable] = mi("w") -> '"w"'
x [variable] = mi("x") -> '"x"'
y [variable] = mi("y") -> '"y"'


A [variable] = mi("A") -> '"cap A"'

B [variable] = mi("B") -> '"cap B"'

C [variable] = mi("C") -> '"cap C"'

D [variable] = mi("D") -> '"cap D"'

E [variable] = mi("E") -> '"cap E"'

F [variable] = mi("F") -> '"cap F"'

G [variable] = mi("G") -> '"cap G"'

H [variable] = mi("H") -> '"cap H"'

I [variable] = mi("I") -> '"cap I"'

J [variable] = mi("J") -> '"cap J"'

K [variable] = mi("K") -> '"cap K"'

L [variable] = mi("L") -> '"cap L"'

M [variable] = mi("M") -> '"cap M"'
N [variable] = mi("N") -> '"cap N"'

O [variable] = mi("O") -> '"cap O"'

P [variable] = mi("P") -> '"cap P"'

Q [variable] = mi("Q") -> '"cap Q"'

R [variable] = mi("R") -> '"cap R"'

S [variable] = mi("S") -> '"cap S"'

T [variable] = mi("T") -> '"cap T"'

U [variable] = mi("U") -> '"cap U"'

V [variable] = mi("V") -> '"cap V"'

W [variable] = mi("W") -> '"cap W"'

X [variable] = mi("X") -> '"cap X"'

Y [variable] = mi("Y") -> '"cap Y"'

Z [variable] = mi("Z") -> '"cap Z"'

// Greek letters

alpha [variable] = mi("&#945;") -> 'alpha'

beta [variable] = mi("&#946;") -> 'beta'

chi [variable] = mi("&#967;") -> 'chi'

del [variable] = mi("&#8711;") -> 'del'

delta [variable] = mi("&#948;") -> 'delta'

delta [variable] = mi("&#8706;") -> 'partial differential'

epsilon [variable] = mi("&#949;") -> 'epsilon'

eta [variable] = mi("&#951;") -> 'eta'

gamma [variable] = mi("&#947;") -> 'gamma'

iota [variable] = mi("&#953;") -> 'iota'

kappa [variable] = mi("&#954;") -> 'kappa'

lambda [variable] = mi("&#955;") -> 'lambda'

mu [variable] = mi("&#956;") -> 'mu'

nu [variable] = mi("&#957;") -> 'nu'

omega [variable] = mi("&#969;") -> 'omega'

omicron [variable] = mi("&#959;") -> 'omicron'

phi [variable] = mi("&#981;") -> 'phi'

phi [variable] = mi("&#966;") -> 'phi'

pi [variable] = mi("&#960;") -> 'pi'

pi [variable] = mi("&#982;") -> 'pi'

psi [variable] = mi("&#968;") -> 'psi'

rho [variable] = mi("&#961;") -> 'rho'

sigma [variable] = mi("&#962;") -> 'sigma'

sigma [variable] = mi("&#963;") -> 'sigma'

tau [variable] = mi("&#964;") -> 'tau'

theta [variable] = mi("&#952;") -> 'theta'

theta [variable] = mi("&#977;") -> 'theta'

upsilon [variable] = mi("&#965;") -> 'upsilon'

xi [variable] = mi("&#958;") -> 'xi'

zeta [variable] = mi("&#950;") -> 'zeta'



Alpha [variable] = mi("&#913;") -> 'alpha'

Beta [variable] = mi("&#914;") -> 'beta'

Chi [variable] = mi("&#935;") -> 'chi'

Delta [variable] = mi("&#916;") -> 'delta'

Epsilon [variable] = mi("&#917;") -> 'epsilon'

Eta [variable] = mi("&#919;") -> 'eta'

Gamma [variable] = mi("&#915;") -> 'gamma'

Iota [variable] = mi("&#921;") -> 'iota'

Kappa [variable] = mi("&#922;") -> 'kappa'

Lambda [variable] = mi("&#923;") -> 'lambda'

Mu [variable] = mi("&#924;") -> 'mu'

Nu [variable] = mi("&#925;") -> 'nu'

Omega [variable] = mi("&#937;") -> 'omega'

Omicron [variable] = mi("&#927;") -> 'omicron'

Phi [variable] = mi("&#934;") -> 'phi'

Pi [variable] = mi("&#928;") -> 'pi'

PiBig [variable] = mo("&#8719;") -> 'big pi'

PiBigFlipped = mo("&#8720;") -> 'flipped big pi'

Psi [variable] = mi("&#936;") -> 'psi'

Rho [variable] = mi("&#929;") -> 'rho'

Sigma [variable] = mi("&#931;") -> 'sigma'

SigmaBig = mo("&#8721;") -> 'sigma'

Tau [variable] = mi("&#932;") -> 'tau'

Theta [variable] = mi("&#920;") -> 'theta'

Upsilon [variable] = mi("&#933;") -> 'upsilon'

UpsilonHook [vaiable] = mi("&#978;") -> 'upsilon with hook'

Xi [variable] = mi("&#926;") -> 'xi'

Zeta [variable] = mi("&#918;") -> 'zeta'


//Rarely used symbols

ahlef = mi("&#8501;") -> 'ahlef'

bbcapC = mi("&#8450;") -> 'blackboard cap C'

bbcapF = mi("&#61573;") -> 'blackboard cap F'

bbcapN = mi("&#8469;") -> 'blackboard cap N'

bbcapQ = mi("&#8474;") -> 'blackboard cap Q'

bbcapS = mi("&#61586;") -> 'blackboard cap S'

bbcapZ = mi("&#8484;") -> 'blackboard cap Z'

bblowK = mi("&#61604;") -> 'blackboard k'

frakturA = mi("&#61440;") -> 'Fraktur cap A'

frakturI = mi("&#8465;") -> 'Fraktur cap I'

frakturM = mi("&#61452;") -> 'Fraktur cap M'

frakturR = mi("&#8476;") -> 'Fraktur cap R'

invertedOhm = mi("&#8487;") -> 'inverted Ohm sign'

planckConsOverTwoPi = mi("&#8463;") -> 'Planck constant over two pi'

scriptI = mi("&#8467;") -> 'Script I'

smallLamExtraStroke = mi("&#411;") -> 'Small lambda with extra stroke'

weierstrassEll = mi("&#8472;") -> 'Weierstrass ellipsis'



// Text
text = mtext(?) -> '{1}'


// Ellipses

diagonalBotLeftEllipsis = mi("&#8944;") -> 'diagonal bottom left top right ellipsis,'

diagonalTopLeftEllipsis = mi("&#8945;") -> 'diagonal top left bottom right ellipsis,'

ellipsis = mi("&#8230;") -> 'ellipsis,'

ellipsis = mi("&#8943;") -> 'ellipsis,'

verticalEllipsis = mi("&#8942;") -> 'vertical ellipsis,'