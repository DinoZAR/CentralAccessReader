//                                                      
//  ,--.      .-'),-----.   ,----.     ,-.-')   .-----.  
//  |  |.-') ( OO'  .-.  ' '  .-./-')  |  |OO) '  .--./  
//  |  | OO )/   |  | |  | |  |_( O- ) |  |  \ |  |('-.  
//  |  |`-' |\_) |  |\|  | |  | .--, \ |  |(_//_) |OO  ) 
// (|  '---.'  \ |  | |  |(|  | '. (_/,|  |_.'||  |`-'|  
//  |      |    `'  '-'  ' |  '--'  |(_|  |  (_'  '--'\  
//  `------'      `-----'   `------'   `--'     `-----'  
//                                                   
// --------------
// Order Matters!
// --------------
//
// The MathML parser is entirely sequential. Once it finds all cases of the
// current pattern and combines the different pattern's elements into singular
// entities, the pattern is no longer used in later matching. This means you
// must order patterns correctly to produce results you expect.
//
// -----------------
// Expected Ordering
// -----------------
//
// In order for patterns to match correctly, you should have patterns grouped
// and have those groups ordered in the following way: 
//
// 1. Symbol Code (like variables and Unicode)
// 2. Fraction-Based (like derivatives)
// 3. Over-Under (like sums and integrals)
// 4. Parenthetical Expressions (like square roots or things in parenthesis)
// 5. Generic Fallbacks (like fractions, superscripting, and subscripting)

// ------------------------------------------------------------------------------
// Symbol Code
// ------------------------------------------------------------------------------

import _codes.txt

//---------------------------------------------------------------
// Trigonometry-Specific
//---------------------------------------------------------------
arccos = a r c c o s -> 'arc cosine'
arcsine = a r c s i n -> 'arc sine'
arctan = a r c t a n -> 'arc tangent'
inverseCosine = c o msup(s mrow(minus one)) -> 'inverse cosine'
cosine = c o s -> 'cosine'
cotangent = c o t -> 'cotangent'
cosecant = c s c -> 'cosecant'
inverseSine = s i msup(n mrow(minus one)) -> 'inverse sine'
secant = s e c -> 'secant'
sine = s i n -> 'sine'
tangent = t a n -> 'tangent'

// Powers and Primes
cubed = msup(? mrow(three)) -> '{1} cubed'
cubed = msup(? three) -> '{1} cubed'
degrees = msup(? mrow(composition)) -> '{1} degrees'
squared = msup(? mrow(two)) -> '{1} squared'
squared = msup(? two) -> '{1} squared'
supDubPrime = msup(? doublePrime) -> '{1} double prime'
supPrime = msup(? prime) -> '{1} prime'
supTriPrime = msup(? triplePrime) -> '{1} triple prime'

//Functions
function = [variable] mrow(openParen [variable] closeParen) -> 'function {1} of {3}'
function = [variable] openParen [variable] closeParen -> 'function {1} of {3}'
function = [variable] mfenced(+) -> 'function {1} of {2}'
functionPrime = [variable] mi("'") mfenced(+) -> 'function {1} prime of {2}'

// Intervals
closedInterval = openBracket ? comma ? closeBracket -> 'Closed interval {2},{4}'
openInterval = openParen ? comma ? closeParen -> 'Open interval {2},{4}'

// Absolute values - !Broken!

// Syntax Quirks
doubleBarSyn = mover(mover(mrow(+) bar) bar) -> '{1} under double bar'
doubleBarSyn = munder(munder(mrow(+) bar) bar) -> '{1} over double bar'
doubleDagger = dagger dagger -> 'double dagger'

// ------------------------------------------------------------------------------
// Fraction-based
// ------------------------------------------------------------------------------
integral = msub([integral] ?) -> '{1} sub {2} of'


// ------------------------------------------------------------------------------
// Conditions for arrows based on over or under
// ------------------------------------------------------------------------------
overBothArrow = munder(? [arrow]) -> '{1} over {2}'
underBothArrow = mover(? [arrow]) -> '{1} under {2}'
overUnderArrowB = munderover([arrow] mrow(+) mrow(+)) -> '{2} above {1} sub {3}'


// ------------------------------------------------------------------------------
// Logic-based
// ------------------------------------------------------------------------------

barWedge = munder(or bar) -> 'bar wedge'
existsOne = exists factorial -> 'backwards E followed by exclamation'
intersection = munderover(intersection mrow() mrow()) -> 'intersection'
notExist = menclose(exists) -> 'backwards E with slash'
parallelBars = verticalBar verticalBar -> 'parallel bars'
quadBars = mover(identical bar) -> 'quadruple bars'
quadBars = munder(identical bar) -> 'quadruple bars'
union = munderover(union mrow() mrow()) -> 'union'

// ------------------------------------------------------------------------------
// Under-Over, Integrals, Products, and Summations
// ------------------------------------------------------------------------------
backPrimes = mmultiscripts(? ? ? ?) -> '{4} {1}'

// Integrals
//integralOU = munderover([integral] mrow(+) mrow(+)) -> 'the {1} from {2} to {3} of'
//integralOU = munderover([integral] mrow(+) mrow()) -> 'the {1} over {2} of'
//integralOU = munderover([integral] mrow() mrow()) -> 'the {1} of'

// Intersections and Limits

limit = munderover(mrow(l i m) mrow(? ? ?) ?) -> 'the limit as {4} approaches {6} of'
limit = munderover(mrow(l i m) mrow(+) ?) -> 'the limit as {4} of'

// Products and Unions

//sum = munderover(SigmaBig ? ?) -> 'the sum from {2} to {3}, of'
//sum = munderover(SigmaBig ? mrow()) -> 'the sum from {2} of'
//sum = munderover(SigmaBig mrow() mrow())-> 'the sum of'
//underover = munderover(? ? ?) -> 'the {1} from {2} to {3}, of'
//underover = munderover(? ?) -> 'the {1} from {2} of'


// ------------------------------------------------------------------------------
// Parenthetical Expressions
// ------------------------------------------------------------------------------
cuberoot = mroot(mrow(+) mrow(three)) -> 'the cube root of {1}'
rootPowers = mroot(mrow(+) mrow(+)) -> 'the {2} root of {1}'
squareRoot = msqrt(+) -> 'the square root of {1}'


// ------------------------------------------------------------------------------
// Matrices
// ------------------------------------------------------------------------------
matrix = mrow(mtable(#)) -> 'matrix {1}'
matrix = mtable(#) -> 'matrix {1}'
matrixPar = mfenced(mrow(mtable(+))) -> 'matrix {1}'
tableColumn = mtd(+) -> '{1},'
tableRow = mtr(+) -> 'row, {1}'


// ------------------------------------------------------------------------------
// Generic Fallbacks, Final Collectors
// ------------------------------------------------------------------------------
// Strikes and Slashes
Strike = menclose(+) -> 'strike {1} end-strike'

fenced = mfenced(+) -> 'open parenthesis, {1}, closed parenthesis,'

under = munder(? ?) -> '{1} over {2}'
over = mover(? ?) -> '{1} under {2}'

fraction = mfrac(? ?) -> '{1} over {2}'
subscript = msub(? ?) -> '{1} sub {2}'
superscript = msup(? ?) -> '{1} to the {2} power'
subsuperscript = msubsup(? ? ?) -> '{1} sub {2} to the {3} power'

row = mrow(+) -> '{1}'
row = mrow() -> ''
style = mstyle(+) -> '{1}'

// This is the final collapsing pattern
final = math(+) -> '{1}'