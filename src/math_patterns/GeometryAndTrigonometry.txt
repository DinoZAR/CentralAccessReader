//   ________                             __                 
//  /  _____/  ____  ____   _____   _____/  |________ ___.__.
// /   \  ____/ __ \/  _ \ /     \_/ __ \   __\_  __ <   |  |
// \    \_\  \  ___(  <_> )  Y Y  \  ___/|  |  |  | \/\___  |
//  \______  /\___  >____/|__|_|  /\___  >__|  |__|   / ____|
//         \/     \/            \/     \/             \/     
//
// --------------
// Order Matters!
// --------------
//
// The MathML parser is entirely sequential. Once it finds all cases of the
// current pattern and combines the different pattern's elements into singular
// entities, the pattern is no longer used in later matching. This means you
// must order patterns correctly to produce results you expect.
//
// -----------------
// Expected Ordering
// -----------------
//
// In order for patterns to match correctly, you should have patterns grouped
// and have those groups ordered in the following way: 
//
// 1. Symbol Code (like variables and Unicode)
// 2. Fraction-Based (like derivatives)
// 3. Over-Under (like sums and integrals)
// 4. Parenthetical Expressions (like square roots or things in parenthesis)
// 5. Generic Fallbacks (like fractions, superscripting, and subscripting)
//
// ------------------------------------------------------------------------------
// Symbol Code
// ------------------------------------------------------------------------------

import _codes.txt

// Unicodes and MathML codes for operators
diamond = mi("&#8900;") -> 'diamond,'
equivalent = equivalent -> 'is similar to'
identical = mi("&#8801;") -> 'is congruent to,'
plus = mo("+") -> 'plus,'
summation = mi("&#8721;") -> 'summation,'
tilde = mo("&#732;") -> 'is similar to,'
tilde = mo("~") -> 'is similar to,'
tilde = mi("~") -> 'is similar to,'
times = mi("&#8901;") -> 'times,'
times = mi("&#59791;") -> 'times,'

// Parentheses, Brackets, Braces, and Bars
closeBrace = mo("}") -> 'close brace,'
closeBracket = mo("]") -> ', close bracket,'
closeParen = mo(")") -> ', close parentheses,'
leftAngleBracket = mi("&#9001;") -> 'left-pointing angle bracket,'
leftAngleBracket = mo("&#9001;") -> 'left-pointing angle bracket,'
openBrace = mo("{") -> 'open brace,'
openBracket = mo("[") -> 'open bracket,'
rightAngleBracket = mi("&#9002;") -> 'right-pointing angle bracket,'
rightAngleBracket = mo("&#9002;") -> 'right-pointing angle bracket,'
bullet = mi("&#8226;") -> 'bullet,'
dot = mo("&#775;") -> 'dot,'
dot = mi("&#183;") -> 'times,'
perpendicular = mi("&#8869;") -> 'perpendicular to,'
square = mi("&#9633;") -> 'square,'

// Logic
and = mo("&#8743;") -> 'and,'
because = mo("&#8757;") -> 'because,'
compliment = mi("&#8705;") -> 'is a compliment of,'
containsNormalSubgroup = mi("&#8883;") -> 'contains as normal subgroup,'
exists = mo("&#8707;") -> 'there exists,'
factorial = mo("!") -> 'factorial,'
forAll = mo("&#8704;") -> 'for all,'
greaterThan = mo("&gt;") -> 'is greater than,'
greaterThan = mi("&gt;") -> 'is greater than,'

isElement = mo("&#8712;") -> 'is an element of,'
isNotElement = mo("&#8713;") -> 'is not an element of,'
lessThan = mo("&lt;") -> 'is less than,'
lessThan = mi("&lt;") -> 'is less than,'
not = mo("&#172;") -> 'not,'
or = mo("&#8744;") -> 'or,'

properSubsetRight = mo("&#8834;") -> 'is a proper subset of,'
properSubsetLeft = mo("&#8835;") -> 'is a proper subset of,'

therefore = mo("&#8756;") -> 'therefore,'

e [variable] = mi("e") -> '"e"'
i [variable] = mi("i") -> '"i"'
z [variable] = mi("z") -> '"z"'

bbcapR = mi("&#8477;") -> 'all real numbers'

// Other symbols

// Strikes and Slashes
Strike = menclose(+) -> 'strike {1} end-strike,'


//---------------------------------------------------------------
// Trigonometry-Specific
//---------------------------------------------------------------

import _Trig.txt

// Powers and Primes

import _PowersPrimes.txt

// Syntax Quirks
doubleBarSyn = mover(mover(mrow(+) bar) bar) -> '{1} under double bar'
doubleBarSyn = munder(munder(mrow(+) bar) bar) -> '{1} over double bar'
doubleDagger = dagger dagger -> 'double dagger'


// ------------------------------------------------------------------------------
// Fraction-based
// ------------------------------------------------------------------------------
integral = msub([integral] ?) -> '{1} sub {2} of,'

// Other symbols
infinity = mi("&#8734;") -> 'infinity'
infinity = mn("&#8734;") -> 'infinity'


// ------------------------------------------------------------------------------
// Geometry Specific
// ------------------------------------------------------------------------------
angles = angle s -> 'angles'
congruent = approxEqualTilde -> 'is congruent to'
parallels = parallel s -> 'parallels'
perpendiculars = perpendicular s -> 'perpendiculars'
underBothArrow = mover(? bar) -> 'the line segment {1},'
underBothArrow = mover(? arc) -> 'the arc {1},'
underBothArrow = mover(? leftArrow) -> 'the directed line segment {1},'
underBothArrow = mover(? rightArrow) -> 'the directed line segment {1},'
thePoint = p colon openParen ? comma ? closeParen -> 'the point {4}, {6},'
thePoint = p openParen ? comma ? closeParen -> 'the point {3}, {5},'
thePoint = openParen ? comma ? closeParen -> 'the point {2}, {4},'
thePoint = openParen ? comma ? comma ? closeParen -> 'the point {2}, {4}, {6}'

// Postulates (do we want these?)
angleangleside = a a s -> 'angle angle side'
angleangleside = a point a point s point -> 'angle angle side'
anglesideangle = a s a -> 'angle side angle'
anglesideangle = a point s point a point -> 'angle side angle'
sideangleside = s a s -> 'side angle side'
sideangleside = s point a point s point -> 'side angle side'
sidesideangle = s s a -> 'side side angle'
sidesideangle = s point s point a point -> 'side side angle'
sidesideside = s s s -> 'side side side'
sidesideside = s point s point s point -> 'side side side'


// ------------------------------------------------------------------------------
// Conditions for arrows based on over or under
// ------------------------------------------------------------------------------
overBothArrow = munder(? [arrow]) -> '{1}, over {2},'
overUnderArrowB = munderover(rightArrow mrow(+) mrow(+)) -> '{2}, above {1}, sub {3},'
overUnderArrowB = munderover(leftArrow mrow(+) mrow(+)) -> '{2}, above {1}, sub {3},'
overUnderArrowB = munderover(bothArrow mrow(+) mrow(+)) -> '{2}, above {1}, sub {3},'
overUnderArrowB = munderover(rightHarpoon mrow(+) mrow(+)) -> '{2}, above {1}, sub {3},'


// ------------------------------------------------------------------------------
// Under-Over, Integrals, Products, and Summations
// ------------------------------------------------------------------------------
backPrimes = mmultiscripts(? ? ? ?) -> '{4} {1}'

// Limits

limit = munderover(mrow(l i m) mrow(? ? ?) ?) -> 'the limit as {4}, approaches {6}, of'
limit = munderover(mrow(l i m) mrow(+) ?) -> 'the limit as {4}, of'

// Products and Unions

import _Integrals.txt


// ------------------------------------------------------------------------------
// Parenthetical Expressions
// ------------------------------------------------------------------------------
absoluteValue = verticalBar + verticalBar -> 'absolute value {2} end absolute'
cuberoot = mroot(mrow(+) mrow(three)) -> 'the cube root of {1}'
rootPowers = mroot(mrow(+) mrow(+)) -> 'the {2} root of {1}'
squareRoot = msqrt(+) -> 'the square root of {1}'


// ------------------------------------------------------------------------------
// Matrices
// ------------------------------------------------------------------------------
matrix = mrow(mtable(#)) -> 'matrix {1}'
matrix = mtable(#) -> 'matrix {1}'
matrixPar = mfenced(mrow(mtable(+))) -> 'matrix {1}'
tableColumn = mtd(+) -> '{1},'
tableRow = mtr(+) -> 'row, {1}'


// ------------------------------------------------------------------------------
// Generic Fallbacks, Final Collectors
// ------------------------------------------------------------------------------
fenced = mfenced(+) -> 'open parenthesis, {1}, closed parenthesis,'

under = munder(? ?) -> '{1} over {2}'
over = mover(? ?) -> '{1} under {2}'
fraction = mfrac(? ?) -> '{1} over {2}'
leftSubSup = msubsup( mrow() mrow(?) mrow(?)) -> 'left subscript {1}, left superscript {2},'
leftSub = msup( mrow() mrow(?)) -> 'left subscript {1},'
leftSup = msub( mrow() mrow(?)) -> 'left superscript {1},'
subscript = msub(? ?) -> '{1} sub {2}'
superscript = msup(? ?) -> '{1} to the {2} power'
subsuperscript = msubsup(? ? ?) -> '{1} sub {2} to the {3} power'

row = mrow(+) -> '{1}'
row = mrow() -> ''
style = mstyle(+) -> '{1}'

// This is the final collapsing pattern
final = math(+) -> '{1}'